// Copyright 2021-2022 Software Quality Laboratory, NYCU.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <s2e/Plugins/CRAX/CRAX.h>
#include <s2e/Plugins/CRAX/Modules/RopChainBuilder.h>
#include <s2e/Plugins/CRAX/Modules/IOStates.h>
#include <s2e/Plugins/CRAX/Techniques/Technique.h>
#include <s2e/Plugins/CRAX/Utils/StringUtil.h>

#include <fstream>

#include "ExploitGenerator.h"

namespace s2e::plugins::crax {

ExploitGenerator::ExploitGenerator(CRAX &ctx) : Module(ctx) {
    // Install the default exploit generation hook.
    ctx.exploitGenerationHooks.connect(
            sigc::mem_fun(*this, &ExploitGenerator::run));
}


void ExploitGenerator::run() {
    if (!generateExploit()) {
        log<WARN>() << "Failed to generate exploit.\n";
    }
}

bool ExploitGenerator::generateExploit() {
    S2EExecutionState *state = m_ctx.getCurrentState();
    ConfigFile *cfg = m_ctx.s2e()->getConfig();
    Exploit &exploit = m_ctx.getExploit();

    // Write exploit shebang.
    exploit.writeline(Exploit::s_shebang);

    // Pwntools stuff.
    exploit.writelines({
        "from pwn import *",
        "context.update(arch = 'amd64', os = 'linux', log_level = 'info')",
        "",
        format("elf = ELF('%s', checksec=False)", exploit.getElfFilename().c_str()),
    });

    // Initialize techniques.
    std::vector<std::unique_ptr<Technique>> techniques;
    ConfigFile::string_list techniqueNames = cfg->getStringList(m_ctx.getConfigKey() + ".techniques");

    foreach2 (it, techniqueNames.begin(), techniqueNames.end()) {
        log<WARN>() << "initializing: " << *it << '\n';
        techniques.push_back(Technique::create(m_ctx, *it));
    }

    // Check requirements.
    for (const auto &t : techniques) {
        if (!t->checkRequirements()) {
            log<WARN>() << "Requirements unsatisfied: " << t->toString() << '\n';
            return false;
        }
    }

    exploit.registerSymbol("elf_base", 0);

    // Declare symbols and values.
    for (const auto &entry : exploit.getSymtab()) {
        const auto &name = entry.first;
        const auto &value = entry.second;
        exploit.writeline(format("%s = 0x%llx", name.c_str(), value));
    }

    exploit.writeline();

    // Write exploit body.
    exploit.writelines({
        "if __name__ == '__main__':",
        "    proc = elf.process()",
    });

    /*
    // Build ROP chain based on the strategy list chosen by the user.
    auto ropChainBuilder = dynamic_cast<RopChainBuilder *>(CRAX::getModule("RopChainBuilder"));
    assert(ropChainBuilder && "Current implementation of CRAX++ requires RopChainBuilder");

    if (!ropChainBuilder->build(exploit, techniques)) {
        return false;
    }
    */

    // LAEG's LeakExploit().
    auto iostates = dynamic_cast<IOStates *>(CRAX::getModule("IOStates"));
    assert(iostates && "Current implementation of CRAX++ requires IOStates");

    DECLARE_PLUGINSTATE_P((&m_ctx), CRAXState, state);
    DECLARE_MODULESTATE_M(iostates, IOStatesState, plgState);

    auto &os = log<WARN>();
    os << "Dumping IOStates: [";
    for (const auto &stateInfo : modState->stateInfoList) {
        if (const auto &inputStateInfo = std::get_if<IOStates::InputStateInfo>(&stateInfo)) {
            os << "input,";
        } else if (const auto &outputStateInfo = std::get_if<IOStates::OutputStateInfo>(&stateInfo)) {
            os << "output,";
        }
    }
    os << "]\n";

    // Write exploit trailer.
    exploit.writeline("    proc.interactive()");

    // Write the buffered content to the file.
    std::string filename = exploit.getFilename(state->getID());
    std::ofstream ofs(filename);
    ofs << exploit.getContent();

    exploit.clearContent();
    //ropChainBuilder->reset();

    log<WARN>() << "Generated exploit script: " << filename << "\n";
    return true;
}

}  // namespace s2e::plugins::crax
