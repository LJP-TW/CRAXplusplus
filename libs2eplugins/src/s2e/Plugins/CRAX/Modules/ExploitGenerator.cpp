// Copyright 2021-2022 Software Quality Laboratory, NYCU.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <s2e/Plugins/CRAX/CRAX.h>
#include <s2e/Plugins/CRAX/Modules/RopChainBuilder.h>
#include <s2e/Plugins/CRAX/Modules/IOStates.h>
#include <s2e/Plugins/CRAX/Techniques/Technique.h>
#include <s2e/Plugins/CRAX/Utils/StringUtil.h>

#include <fstream>

#include "ExploitGenerator.h"

namespace s2e::plugins::crax {

ExploitGenerator::ExploitGenerator(CRAX &ctx) : Module(ctx) {
    // Install the default exploit generation hook.
    ctx.exploitGenerationHooks.connect(
            sigc::mem_fun(*this, &ExploitGenerator::run));
}


void ExploitGenerator::run() {
    if (!generateExploit()) {
        log<WARN>() << "Failed to generate exploit.\n";
    }
}

bool ExploitGenerator::generateExploit() {
    S2EExecutionState *state = m_ctx.getCurrentState();
    ConfigFile *cfg = m_ctx.s2e()->getConfig();
    Exploit &exploit = m_ctx.getExploit();

    // Write exploit shebang.
    exploit.writeline(Exploit::s_shebang);

    // Pwntools stuff.
    exploit.writelines({
        "from pwn import *",
        "context.update(arch = 'amd64', os = 'linux', log_level = 'info')",
        "",
        format("elf = ELF('%s', checksec=False)", exploit.getElfFilename().c_str()),
    });

    // Initialize techniques.
    std::vector<std::unique_ptr<Technique>> techniques;
    ConfigFile::string_list techniqueNames = cfg->getStringList(m_ctx.getConfigKey() + ".techniques");

    foreach2 (it, techniqueNames.begin(), techniqueNames.end()) {
        log<WARN>() << "initializing: " << *it << '\n';
        techniques.push_back(Technique::create(m_ctx, *it));
    }

    // Check requirements.
    for (const auto &t : techniques) {
        if (!t->checkRequirements()) {
            log<WARN>() << "Requirements unsatisfied: " << t->toString() << '\n';
            return false;
        }
    }

    exploit.registerSymbol("elf_base", 0);

    // Declare symbols and values.
    for (const auto &entry : exploit.getSymtab()) {
        const auto &name = entry.first;
        const auto &value = entry.second;
        exploit.writeline(format("%s = 0x%llx", name.c_str(), value));
    }

    exploit.writeline();

    // Write exploit body.
    exploit.writelines({
        "if __name__ == '__main__':",
        "    proc = elf.process()",
    });

    /*
    // Build ROP chain based on the strategy list chosen by the user.
    auto ropChainBuilder = dynamic_cast<RopChainBuilder *>(CRAX::getModule("RopChainBuilder"));
    assert(ropChainBuilder && "Current implementation of CRAX++ requires RopChainBuilder");

    if (!ropChainBuilder->build(exploit, techniques)) {
        return false;
    }
    */

    // LAEG's LeakExploit().
    auto iostates = dynamic_cast<IOStates *>(CRAX::getModule("IOStates"));
    assert(iostates && "Current implementation of CRAX++ requires IOStates");
    iostates->print();

    auto modState = m_ctx.getPluginModuleState(state, iostates);

    for (const auto &i : modState->stateInfoList) {
        exploit.writeline();

        using InputStateInfo = IOStates::InputStateInfo;
        using OutputStateInfo = IOStates::OutputStateInfo;
        
        if (const auto stateInfo = std::get_if<InputStateInfo>(&i)) {
            exploit.writeline(format("    # input state (offset = %d)", stateInfo->offset));
            std::string byteString = toByteString(stateInfo->buf.begin(),
                                                  stateInfo->buf.begin() + stateInfo->offset);
            //log<WARN>() << "<input state>: buf(" << hexval(stateInfo->offset) << ")=" << buf << '\n';
            exploit.writeline(format("    proc.send(%s)", byteString.c_str()));

        } else if (const auto stateInfo = std::get_if<OutputStateInfo>(&i)) {
            exploit.writeline("    # output state");
            if (!stateInfo->valid) {
                exploit.writeline("    proc.recvrepeat(0.1)");
                continue;
            }

            exploit.writeline(
                    format("    # leaking: %s", IOStates::s_leakTypes[stateInfo->leakType].c_str()));

            if (stateInfo->leakType == IOStates::LeakType::CANARY) {
                exploit.writelines({
                    format("    proc.recv(%d)", stateInfo->bufIndex),
                    "    canary = b'\\x00' + proc.recv(7)",
                    "    log.info('leaked canary: {}'.format(hex(u64(canary))))",
                });
            } else {
                exploit.writelines({
                        format("    proc.recv(%d)", stateInfo->bufIndex),
                        "    addrLeak = proc.recv(8)",
                        format("    addrBase = u64(addrLeak) - 0x%x", stateInfo->baseOffset),
                });
            }
        }
    }

    // Write exploit trailer.
    exploit.writeline("    proc.interactive()");

    // Write the buffered content to the file.
    std::string filename = exploit.getFilename(state->getID());
    std::ofstream ofs(filename);
    ofs << exploit.getContent();

    exploit.clearContent();
    //ropChainBuilder->reset();

    log<WARN>() << "Generated exploit script: " << filename << "\n";
    return true;
}

}  // namespace s2e::plugins::crax
